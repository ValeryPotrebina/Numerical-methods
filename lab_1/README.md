% Лабораторная работа № 1 «Решение СЛАУ с трёхдиагональной матрицей методом
прогонки»
% Валерия Потребина, ИУ9-62Б

# Цель работы
Целью данной работы является реализация программы для решения
разряженных СЛАУ методом прогонки, в которые ненулевых элементов
огранниченное количество.

# Задание
В ряде случаев практическая задача сводится к решению разреженных
СЛАУ, в которых ненулевые элементов ограниченное количество. Как
правило, речь идет о ленточных матрицах, где ненулевые элементы
находятся на главной диагонали и смежных с ней

# Реализация

Файл `Main.go`:
```
package main

import (
	"fmt"
	"math"
)

// че та проверить в узлах интерполяции (щас высчитывается между ними ) - последний столбик, там д.б. дроби меньше
func run_through_method(A [30][30]float64, d []float64) []float64 {
	var alpha, beta, x []float64
	//прямой ход
	for i := 0; i < len(A); i++ {
		if i == 0 {
			alph := -1 * A[i][i+1] / A[i][i]
			bet := d[i] / A[i][i]
			alpha = append(alpha, alph)
			beta = append(beta, bet)
		} else if i == len(A)-1 {
			alpha = append(alpha, 0)
			bet := (d[i] - A[i][i-1]*beta[i-1]) / (A[i][i-1]*alpha[i-1] + A[i][i])
			beta = append(beta, bet)
		} else {
			alph := -1 * A[i][i+1] / (A[i][i-1]*alpha[i-1] + A[i][i])
			bet := (d[i] - A[i][i-1]*beta[i-1]) / (A[i][i-1]*alpha[i-1] + A[i][i])
			alpha = append(alpha, alph)
			beta = append(beta, bet)
		}

	}

	//обратный ход
	for i := len(A) - 1; i >= 0; i-- {
		if i == len(A)-1 {
			temp := beta[i]
			x = append(x, temp)
		} else {
			temp := alpha[i]*x[len(x)-1] + beta[i]
			x = append(x, temp)
		}
	}

	var right_x []float64

	for i := len(x) - 1; i >= 0; i-- {
		right_x = append(right_x, x[i])
	}
	right_x[0] = 0
	right_x[len(right_x)-1] = 0
	return right_x
}

func tab(alph, bet float64) {
	n := 32
	h := (bet - alph) / float64(n)
	var x, y, x1, y1 []float64
	for i := alph; i <= bet; i += h {
		x = append(x, i)
		temp := i / (math.Pow(i, 2) - 2*i - 3)
		y = append(y, temp)

	}

	var a, b, d, c []float64

	//подготовка к методу прогонки
	var left []float64
	var mat [30][30]float64
	for i := 1; i < 31; i++ {
		left = append(left, (3/math.Pow(h, 2))*(y[i+1]-2*y[i]+y[i-1]))
	}
	for i := 0; i < (n - 2); i++ {
		for j := 0; j < 30; j++ {
			if i == j {
				mat[i][j] = 4
			} else if (i-j == 1) || (j-i == 1) {
				mat[i][j] = 1
			}
		}
	}
	c = append(c, 0)
	c = append(c, run_through_method(mat, left)...)
	c = append(c, 0)

	for i := 0; i < n-1; i++ {
		a = append(a, y[i])
		b = append(b, (y[i+1]-y[i])/h-(h/3)*(c[i+1]+2*c[i]))
		d = append(d, (c[i+1]-c[i])/(3*h))
	}

	for i := 1; i < n; i++ {
		xx := alph + (float64(i)-0.5)*h
		x1 = append(x1, xx)
		temp := xx * math.Pow(math.Sin(xx), 2)
		y1 = append(y1, temp)
	}

	var f, ff []float64

	for i := 0; i < n-1; i++ {
		f = append(f, a[i]+b[i]*(x1[i]-x[i])+c[i]*math.Pow(x1[i]-x[i], 2)+d[i]*math.Pow(x1[i]-x[i], 3))
		ff = append(ff, math.Abs(f[i]-y[i]))
	}

	fmt.Println("i \t x\t\t f\t\t y\t\t |f-y|")
	for i := 0; i < n-1; i++ {
		fmt.Printf("%d:\t%f\t%f\t%f\t%f\n", i, x[i], f[i], y[i], ff[i])
	}

}

func main() {
	tab(-0.5, 2.5)
}

```



# Тестирование

Вывод на `stdout`

```
i        x               f               y               |f-y|
0:      -0.500000       0.243292        0.285714        0.042423
1:      -0.406250       0.168389        0.200869        0.032480
2:      -0.312500       0.110866        0.137221        0.026355
3:      -0.218750       0.065401        0.086990        0.021589
4:      -0.125000       0.027538        0.045714        0.018176
5:      -0.031250       -0.005158       0.010642        0.015800
6:      0.062500        -0.034107       -0.020025       0.014082
7:      0.156250        -0.060365       -0.047520       0.012845
8:      0.250000        -0.084686       -0.072727       0.011959
9:      0.343750        -0.107650       -0.096306       0.011344
10:     0.437500        -0.129716       -0.118770       0.010946
11:     0.531250        -0.151262       -0.140532       0.010729
12:     0.625000        -0.172615       -0.161943       0.010672
13:     0.718750        -0.194071       -0.183313       0.010759
14:     0.812500        -0.215911       -0.204926       0.010985
15:     0.906250        -0.238412       -0.227061       0.011351
16:     1.000000        -0.261863       -0.250000       0.011863
17:     1.093750        -0.286573       -0.274040       0.012533
18:     1.187500        -0.312890       -0.299507       0.013383
19:     1.281250        -0.341215       -0.326775       0.014441
20:     1.375000        -0.372021       -0.356275       0.015746
21:     1.468750        -0.405884       -0.388530       0.017354
22:     1.562500        -0.443517       -0.424178       0.019339
23:     1.656250        -0.485826       -0.464022       0.021805
24:     1.750000        -0.533991       -0.509091       0.024900
25:     1.843750        -0.589564       -0.560737       0.028827
26:     1.937500        -0.654703       -0.620776       0.033927
27:     2.031250        -0.732282       -0.691719       0.040563
28:     2.125000        -0.827036       -0.777143       0.049893
29:     2.218750        -0.947464       -0.882330       0.065134
30:     2.312500        -1.102600       -1.015437       0.087163

```
